### **1.Tổng quan về Auto Scaling Group (Nhóm Tự động điều chỉnh quy mô):**

- Một Auto Scaling Group chứa một tập hợp các phiên bản Amazon EC2.
- Các phiên bản này được coi là một nhóm logic để phục vụ mục đích tự động điều chỉnh quy mô và quản lý.
- Auto Scaling Group cho phép bạn sử dụng các tính năng của Amazon EC2 Auto Scaling như:
  - **Thay thế phiên bản không khỏe (health check replacements):** Tự động thay thế các phiên bản EC2 bị lỗi.
  - **Chính sách điều chỉnh quy mô (scaling policies):** Tự động thay đổi số lượng phiên bản dựa trên các điều kiện.
- **Chức năng cốt lõi** của dịch vụ EC2 Auto Scaling là:
  - Duy trì số lượng phiên bản trong một Auto Scaling Group theo mong muốn.
  - Tự động điều chỉnh quy mô (tăng/giảm số lượng phiên bản).
- Kích thước của một Auto Scaling Group phụ thuộc vào **Số lượng phiên bản mong muốn (Desired capacity)** mà bạn thiết lập.
- Bạn có thể điều chỉnh kích thước nhóm để đáp ứng nhu cầu, bằng cách **thủ công** hoặc sử dụng **tự động điều chỉnh quy mô**.

**Các Tùy chọn Điều chỉnh Quy mô Động (Dynamic Scaling Options):**

Đoạn văn đề cập đến hai loại chính sách điều chỉnh quy mô động:

1. **Chính sách Điều chỉnh Quy mô theo Bước (Step Scaling Policies):**
2. **Chính sách Điều chỉnh Quy mô Đơn giản (Simple Scaling Policies):**

- **Điểm giống nhau:**
  - Cả hai đều yêu cầu bạn tạo **Báo động CloudWatch (CloudWatch alarms)** để kích hoạt chính sách.
  - Cả hai đều yêu cầu bạn chỉ định **ngưỡng cao và thấp** cho các báo động.
  - Cả hai đều yêu cầu bạn xác định liệu sẽ **thêm hoặc bớt** bao nhiêu phiên bản, hoặc đặt kích thước nhóm về một con số **chính xác**.
- **Điểm khác biệt chính:** Chính sách theo bước (Step Scaling) sử dụng các "điều chỉnh theo bước" (step adjustments). Khi các điều chỉnh theo bước được áp dụng, chúng làm tăng hoặc giảm số lượng phiên bản hiện tại của nhóm. **Các điều chỉnh này thay đổi dựa trên mức độ vượt ngưỡng của báo động (size of the alarm breach).** Nghĩa là, nếu báo động vượt ngưỡng nhiều hơn, sự điều chỉnh theo bước có thể lớn hơn.

**Vấn đề của Chính sách Điều chỉnh Quy mô Đơn giản (Simple Scaling):**

- Vấn đề chính của Simple Scaling là **sau khi một hoạt động điều chỉnh quy mô được bắt đầu, chính sách phải đợi cho hoạt động đó (hoặc việc thay thế phiên bản không khỏe) hoàn thành VÀ thời gian chờ làm mát (cooldown period) kết thúc** trước khi phản hồi các báo động tiếp theo.
- **Thời gian chờ làm mát (Cooldown period):** Giúp ngăn chặn việc bắt đầu các hoạt động điều chỉnh quy mô bổ sung trước khi các hiệu ứng của hoạt động trước đó kịp hiển thị và ổn định. Điều này tránh việc nhóm liên tục tăng/giảm không kiểm soát.

**Chính sách Điều chỉnh Quy mô theo Mục tiêu (Target Tracking Scaling Policy):**

- Với chính sách này, bạn có thể tăng hoặc giảm số lượng phiên bản hiện tại của nhóm dựa trên **giá trị mục tiêu (target value)** cho một **chỉ số (metric)** cụ thể (ví dụ: giữ mức sử dụng CPU trung bình ở mức 60%).
- Chính sách này giúp giải quyết vấn đề **cấp phát dư thừa tài nguyên (over-provisioning)**, tối ưu hóa chi phí.
- Chính sách sẽ tự động thêm hoặc bớt phiên bản khi cần thiết để giữ cho chỉ số ở mức, hoặc **gần mức, giá trị mục tiêu** đã chỉ định.
- Ngoài việc giữ chỉ số gần mục tiêu, chính sách Target Tracking còn tự điều chỉnh theo **sự thay đổi của chỉ số do mô hình tải thay đổi**. Nghĩa là nó phản ứng linh hoạt với sự biến động của lưu lượng truy cập.

**Kết luận\: Sử dụng chính sách điều chỉnh quy mô theo mục tiêu (Target Tracking scaling).**

**Giải thích tại sao các tùy chọn khác không phải là đáp án đúng (dựa trên đoạn văn):**

- **Sử dụng Simple scaling là không đúng:** Bởi vì bạn cần phải đợi thời gian chờ làm mát (cooldown period) hoàn thành trước khi bắt đầu các hoạt động điều chỉnh quy mô bổ sung. Chính sách Target tracking hoặc Step scaling có thể kích hoạt một hoạt động điều chỉnh quy mô ngay lập tức mà không cần đợi thời gian chờ làm mát kết thúc ([đoạn văn ngụ ý vậy, mặc dù Step scaling cũng có cơ chế xử lý cooldown phức tạp hơn Simple scaling](./ngoài-lề/step-scaling-cooldown.md)).
- **Sử dụng Scheduled scaling là không đúng:** Bởi vì chính sách này chủ yếu được sử dụng cho các **mô hình lưu lượng truy cập có thể dự đoán (predictable traffic patterns)** (ví dụ: tăng quy mô vào 8 giờ sáng thứ Hai hàng tuần). Bạn cần sử dụng chính sách Target tracking scaling để tối ưu hóa chi phí cơ sở hạ tầng mà không ảnh hưởng đến hiệu suất khi tải **không thể đoán trước** hoặc thay đổi liên tục.
- **Sử dụng Suspend and resume scaling là không đúng:** Bởi vì loại này được sử dụng để **tạm thời tạm dừng** các hoạt động điều chỉnh quy mô được kích hoạt bởi các chính sách (scaling policies) hoặc các hành động theo lịch trình (scheduled actions) của bạn, chứ không phải là một chính sách để tự động điều chỉnh quy mô theo tải.

Tóm lại, mặc dù Simple và Step scaling đều dựa trên báo động, Simple scaling có nhược điểm là phải đợi cooldown. Target Tracking là lựa chọn tốt hơn để tự động điều chỉnh quy mô một cách linh hoạt, giữ chỉ số mục tiêu và tối ưu chi phí cho tải lượng thay đổi, không thể đoán trước, khác với Scheduled scaling chỉ dùng cho tải lượng có thể dự đoán. "Suspend and resume" không phải là một chính sách điều chỉnh quy mô theo tải. Do đó, trong ngữ cảnh cần tối ưu chi phí và hiệu suất theo tải thay đổi, Target Tracking scaling được đề xuất là giải pháp đúng.


### **2.mã hóa phía client (client-side encryption) trong Amazon S3 và lý do chọn giải pháp sử dụng khóa chính phía client (client-side master key):**

**Mã hóa phía Client (Client-side Encryption) là gì?**

- Mã hóa phía client là hành động **mã hóa dữ liệu trước khi gửi nó đến Amazon S3** .
- Điều này có nghĩa là dữ liệu của bạn được mã hóa trên máy tính/máy chủ của bạn (phía client) trước khi nó rời đi để tải lên S3.

**Các Tùy chọn để Bật Mã hóa phía Client:**

Đoạn văn đề cập đến hai tùy chọn chính để thực hiện mã hóa phía client:

1. **Sử dụng Khóa AWS KMS (Use an AWS KMS key):**
   - Khi sử dụng tùy chọn này, bạn cung cấp một **định danh khóa AWS KMS (KeyId)** cho AWS.
   - Quá trình mã hóa dữ liệu thực tế vẫn diễn ra trên phía client (sử dụng AWS SDK), nhưng KMS key của bạn (được quản lý bởi AWS KMS) được sử dụng để mã hóa khóa dữ liệu (data key - sẽ giải thích bên dưới). AWS KMS thực hiện các hoạt động mã hóa/giải mã cho khóa dữ liệu.
2. **Sử dụng Khóa Chính phía Client (Use a client-side master key):**
   - Khi sử dụng tùy chọn này, bạn tự quản lý khóa chính của mình (master key) trên phía client.
   - Điểm cực kỳ quan trọng ở đây là: **Khóa chính phía client của bạn VÀ dữ liệu chưa được mã hóa của bạn KHÔNG BAO GIỜ được gửi đến AWS.**
   - Bạn phải tự quản lý khóa chính này một cách an toàn. Nếu bạn làm mất khóa, bạn sẽ không thể giải mã dữ liệu của mình.

**Cách Hoạt động của Mã hóa phía Client sử dụng Khóa Chính phía Client:**

Quá trình này bao gồm hai giai đoạn:

- **Khi tải lên một đối tượng (Uploading an object):**
  1. Bạn cung cấp khóa chính phía client cho thư viện mã hóa S3 (Amazon S3 encryption client) trên phía client của bạn.
  2. Client (trên máy bạn) **tự tạo ra một khóa đối xứng dùng một lần (one-time-use symmetric key)** , còn gọi là khóa dữ liệu (data encryption key hoặc data key) **ngay tại máy cục bộ** .
  3. Client sử dụng khóa dữ liệu này để mã hóa dữ liệu **của chỉ một đối tượng S3 duy nhất** . Client tạo một khóa dữ liệu riêng biệt cho mỗi đối tượng bạn tải lên.
  4. Sau khi mã hóa dữ liệu đối tượng bằng khóa dữ liệu, client sử dụng **khóa chính phía client (master key bạn cung cấp)** để mã hóa **khóa dữ liệu** (chứ không phải dữ liệu đối tượng).
  5. Client tải lên S3:
     - Dữ liệu đối tượng đã được mã hóa (bằng khóa dữ liệu).
     - Khóa dữ liệu đã được mã hóa (bằng khóa chính phía client), được lưu dưới dạng metadata của đối tượng (ví dụ: `x-amz-meta-x-amz-key`).
     - Thông tin mô tả vật liệu mã hóa (material description) cũng là một phần của metadata, giúp client sau này biết dùng khóa chính nào để giải mã.
- **Khi tải xuống một đối tượng (Downloading an object):**
  1. Client tải xuống đối tượng đã được mã hóa từ S3.
  2. Sử dụng thông tin mô tả vật liệu mã hóa từ metadata của đối tượng, client xác định **khóa chính phía client (master key) nào cần dùng** để giải mã khóa dữ liệu.
  3. Client sử dụng khóa chính đó để giải mã khóa dữ liệu đã được mã hóa từ metadata.
  4. Cuối cùng, client sử dụng khóa dữ liệu đã được giải mã để giải mã dữ liệu đối tượng thực tế.

**Tại sao "Sử dụng S3 client-side encryption với client-side master key" là đáp án đúng?**

Đoạn văn chỉ ra rằng trong kịch bản đang xét, **khóa chính (master keys) VÀ dữ liệu chưa được mã hóa (unencrypted data) KHÔNG BAO GIỜ được gửi đến AWS.**

- Chính sách "Sử dụng S3 client-side encryption với client-side master key" hoàn toàn đáp ứng yêu cầu này:
  - Dữ liệu chưa được mã hóa được mã hóa trên phía client trước khi gửi đi.
  - Khóa chính (client-side master key) được quản lý hoàn toàn bởi bạn trên phía client và không bao giờ rời khỏi môi trường của bạn để đến AWS.

**Giải thích tại sao các tùy chọn khác không đúng (dựa trên kịch bản và đoạn văn):**

1. **"Sử dụng S3 client-side encryption với AWS KMS key" là không đúng:**

   - Mặc dù dữ liệu chưa mã hóa được mã hóa trên client trước khi gửi, nhưng bạn lại **cung cấp định danh khóa AWS KMS (KeyId) cho AWS** .
   - Quan trọng hơn, các hoạt động mã hóa/giải mã cho **khóa dữ liệu** được thực hiện bởi **dịch vụ AWS KMS** do AWS quản lý. Điều này đi ngược lại yêu cầu "khóa chính KHÔNG BAO GIỜ được gửi đến AWS" vì khóa KMS (đóng vai trò là khóa chính để bảo vệ khóa dữ liệu) được quản lý bởi AWS.

2. **"Sử dụng S3 server-side encryption với AWS KMS key" là không đúng:**

   - Đây là mã hóa phía máy chủ (server-side), nghĩa là **dữ liệu chưa được mã hóa được gửi đến S3 trước** và việc mã hóa xảy ra trên phía S3 khi dữ liệu được ghi vào ổ đĩa. Điều này vi phạm yêu cầu "dữ liệu chưa được mã hóa KHÔNG BAO GIỜ được gửi đến AWS".
   - Hơn nữa, khóa chính được sử dụng (KMS key) được quản lý bởi dịch vụ AWS KMS do AWS vận hành, vi phạm yêu cầu "khóa chính KHÔNG BAO GIỜ được gửi đến AWS".

3. **"Sử dụng S3 server-side encryption với customer provided key (SSE-C)" là không đúng:**

   - Đây cũng là mã hóa phía máy chủ (server-side), nên **dữ liệu chưa được mã hóa được gửi đến S3 trước** , vi phạm yêu cầu đầu tiên.
   - Mặc dù bạn "cung cấp" khóa, nhưng bạn **gửi khóa mã hóa đó như một phần của yêu cầu tải lên đối tượng đến S3** . S3 sau đó sử dụng khóa đó để mã hóa/giải mã. Điều này vi phạm yêu cầu "khóa chính KHÔNG BAO GIỜ được gửi đến AWS" vì bạn đã gửi khóa đó đến dịch vụ S3 của AWS.

   giải thích dễ hình dung hơn

   Đây là tóm tắt đầy đủ và logic lại các điểm chính từ đầu đến giờ:

   Chúng ta có các cách chính để mã hóa dữ liệu trên S3:

   1. **Mã hóa phía Máy chủ (Server-Side Encryption - SSE):**
      - Dữ liệu chưa được mã hóa **được gửi đến S3 trước** .
      - AWS (dịch vụ S3) thực hiện việc mã hóa dữ liệu khi ghi vào đĩa.
      - Các loại SSE khác nhau ở cách quản lý khóa: S3 quản lý (SSE-S3), dùng KMS (SSE-KMS), hoặc bạn cung cấp khóa cho S3 (SSE-C).
      - **Điểm mấu chốt:** Phương pháp này **không đáp ứng yêu cầu dữ liệu chưa mã hóa không được gửi đến AWS** , vì dữ liệu đi đến S3 trước khi được mã hóa.
   2. **Mã hóa phía Client (Client-Side Encryption - CSE):**
      - Dữ liệu **được mã hóa trên máy tính/máy chủ của bạn (phía client) trước khi gửi lên S3** .
      - Có hai cách để thực hiện CSE, khác nhau ở việc quản lý "khóa chính" (master key) dùng để bảo vệ "khóa dữ liệu" (Data Key) được dùng mã hóa dữ liệu thực tế:
        - **CSE với Khóa Chính phía Client (CSE with Client-Side Master Key):**
          - Dữ liệu được mã hóa bằng **Data Key** ngay tại client.
          - **Data Key** này được mã hóa bằng **Khóa Chính (Master Key) do bạn TỰ quản lý hoàn toàn trên phía client** .
          - **Điểm mấu chốt:** Cả **dữ liệu chưa mã hóa** và **Khóa Chính** đều **KHÔNG BAO GIỜ được gửi đến AWS** . Đây là phương pháp duy nhất đáp ứng yêu cầu nghiêm ngặt nhất.
        - **CSE với Khóa AWS KMS (CSE with AWS KMS Key):**
          - Dữ liệu được mã hóa bằng **Data Key** ngay tại client.
          - **Data Key** này được mã hóa bằng **Khóa KMS (KMS Key)** mà bạn chỉ định.
          - **Điểm mấu chốt:** Khóa KMS này **được AWS quản lý và lưu trữ trong dịch vụ AWS KMS** ("nằm ở AWS"). Bạn tương tác với dịch vụ KMS (bên phía AWS) thông qua API để mã hóa/giải mã Data Key. Phương pháp này **không đáp ứng yêu cầu Khóa Chính không được gửi đến AWS** (vì Khóa KMS chính là Khóa Chính và nó do AWS quản lý/sử dụng).

   **Kết luận (cho kịch bản nghiêm ngặt):**

   Khi có yêu cầu **nghiêm ngặt** rằng cả **dữ liệu chưa được mã hóa** và **khóa chính (master key)** đều **KHÔNG BAO GIỜ được gửi đến AWS** , thì lựa chọn **duy nhất** phù hợp là **Mã hóa phía Client với Khóa Chính phía Client (CSE with Client-Side Master Key)** .

   Các phương pháp khác đều vi phạm ít nhất một trong hai yêu cầu đó (SSE gửi dữ liệu chưa mã hóa; CSE/KMS sử dụng Khóa Chính nằm ở AWS).
